// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var E, Engine, bufferify, gpg, iced, parse, set_log, spawn, stream, __iced_k, __iced_k_noop, _log;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  spawn = require('child_process').spawn;

  stream = require('./stream');

  E = require('./err').E;

  parse = require('pgp-utils').userid.parse;

  _log = console.warn;

  exports.set_log = set_log = function(log) {
    return _log = log;
  };

  exports.Engine = Engine = (function() {
    function Engine(_arg) {
      this.args = _arg.args, this.stdin = _arg.stdin, this.stdout = _arg.stdout, this.stderr = _arg.stderr;
      this.name = "gpg";
      this.stderr || (this.stderr = new stream.FnOutStream(_log));
      this.stdin || (this.stdin = new stream.NullInStream());
      this.stdout || (this.stdout = new stream.NullOutStream());
      this._exit_code = null;
      this._exit_cb = null;
    }

    Engine.prototype.run = function() {
      this.proc = spawn(this.name, this.args);
      this.stdin.pipe(this.proc.stdin);
      this.proc.stdout.pipe(this.stdout);
      this.proc.stderr.pipe(this.stderr);
      this.pid = this.proc.pid;
      this.proc.on('exit', (function(_this) {
        return function(status) {
          return _this._got_exit(status);
        };
      })(this));
      return this;
    };

    Engine.prototype._got_exit = function(status) {
      var ecb;
      this._exit_code = status;
      this.proc = null;
      if ((ecb = this._exit_cb) != null) {
        this._exit_cb = null;
        ecb(status);
      }
      return this.pid = -1;
    };

    Engine.prototype.wait = function(cb) {
      if (this._exit_code) {
        return cb(this._exit_code);
      } else {
        return this._exit_cb = cb;
      }
    };

    return Engine;

  })();

  bufferify = function(x) {
    if (x == null) {
      return null;
    } else if (typeof x === 'string') {
      return new Buffer(x, 'utf8');
    } else if (Buffer.isBuffer(x)) {
      return x;
    } else {
      return null;
    }
  };

  exports.gpg = gpg = function(_arg, cb) {
    var args, b, def_out, err, out, quiet, rc, stderr, stdin, stdout, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    args = _arg.args, stdin = _arg.stdin, stdout = _arg.stdout, stderr = _arg.stderr, quiet = _arg.quiet;
    if ((b = bufferify(stdin)) != null) {
      stdin = new stream.BufferInStream(b);
    }
    if (quiet) {
      stderr = new stream.NullOutStream();
    }
    if (stdout == null) {
      def_out = true;
      stdout = new stream.BufferOutStream();
    } else {
      def_out = false;
    }
    err = null;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/gpg-wrapper/src/gpg.iced"
        });
        (new Engine({
          args: args,
          stdin: stdin,
          stdout: stdout,
          stderr: stderr
        })).run().wait(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return rc = arguments[0];
            };
          })(),
          lineno: 68
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (rc !== 0) {
          err = new E.GpgError("exit code " + rc);
          err.rc = rc;
        }
        out = def_out != null ? stdout.data() : null;
        return cb(err, out);
      };
    })(this));
  };

  exports.assert_no_collision = function(short_id, cb) {
    var args, err, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    args = ["-k", short_id];
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/gpg-wrapper/src/gpg.iced",
          funcname: "assert_no_collision"
        });
        gpg({
          args: args,
          quiet: true
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return out = arguments[1];
            };
          })(),
          lineno: 79
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if ((typeof err === "undefined" || err === null) && (stream.grep({
          pattern: "/" + short_id,
          buffer: out
        })).length > 1) {
          err = new E.PgpIdCollisionError("Found two keys for ID=" + short_id);
        }
        return cb(err);
      };
    })(this));
  };

  exports.read_uids_from_key = function(_arg, cb) {
    var args, err, fingerprint, line, lines, m, out, pattern, u, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    fingerprint = _arg.fingerprint;
    args = ["-k", fingerprint];
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/gpg-wrapper/src/gpg.iced",
          funcname: "read_uids_from_key"
        });
        gpg({
          args: args,
          quiet: true
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return out = arguments[1];
            };
          })(),
          lineno: 88
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (typeof err === "undefined" || err === null) {
          pattern = /^uid\s+(.*)$/;
          lines = stream.grep({
            buffer: out,
            pattern: pattern
          });
          out = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              if (((m = line.match(pattern)) != null) && ((u = parse(m[1])) != null)) {
                _results.push(u);
              }
            }
            return _results;
          })();
        }
        return cb(err, out);
      };
    })(this));
  };

}).call(this);
