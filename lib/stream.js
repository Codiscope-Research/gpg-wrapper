// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var BufferInStream, BufferOutStream, FnOutStream, NullInStream, NullOutStream, colgrep, stream,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  stream = require('stream');

  exports.NullInStream = NullInStream = (function(_super) {
    __extends(NullInStream, _super);

    function NullInStream() {
      return NullInStream.__super__.constructor.apply(this, arguments);
    }

    NullInStream.prototype._read = function(sz) {
      this.push(null);
      return true;
    };

    return NullInStream;

  })(stream.Readable);

  exports.NullOutStream = NullOutStream = (function(_super) {
    __extends(NullOutStream, _super);

    function NullOutStream() {
      return NullOutStream.__super__.constructor.apply(this, arguments);
    }

    NullOutStream.prototype._write = function(dat) {
      return true;
    };

    return NullOutStream;

  })(stream.Writable);

  exports.BufferInStream = BufferInStream = (function(_super) {
    __extends(BufferInStream, _super);

    function BufferInStream(buf, options) {
      this.buf = buf;
      BufferInStream.__super__.constructor.call(this, options);
    }

    BufferInStream.prototype._read = function(sz) {
      var n, push_me;
      push_me = null;
      if (this.buf.length > 0) {
        n = Math.min(sz, this.buf.length);
        push_me = this.buf.slice(0, n);
        this.buf = this.buf.slice(n);
      }
      this.push(push_me);
      return true;
    };

    return BufferInStream;

  })(stream.Readable);

  exports.BufferOutStream = BufferOutStream = (function(_super) {
    __extends(BufferOutStream, _super);

    function BufferOutStream(options) {
      this._v = [];
      BufferOutStream.__super__.constructor.call(this, options);
    }

    BufferOutStream.prototype._write = function(dat, encoding, cb) {
      this._v.push(dat);
      return cb();
    };

    BufferOutStream.prototype.data = function() {
      return Buffer.concat(this._v);
    };

    return BufferOutStream;

  })(stream.Writable);

  exports.FnOutStream = FnOutStream = (function(_super) {
    __extends(FnOutStream, _super);

    function FnOutStream(fn, options) {
      this.fn = fn;
      FnOutStream.__super__.constructor.call(this, options);
    }

    FnOutStream.prototype._write = function(dat, encoding, cb) {
      this.fn(dat);
      return cb();
    };

    return FnOutStream;

  })(stream.Writable);

  exports.grep = function(_arg) {
    var buffer, line, lines, out, pattern;
    pattern = _arg.pattern, buffer = _arg.buffer;
    lines = buffer.toString('utf8').split('\n');
    out = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        if (line.match(pattern)) {
          _results.push(line);
        }
      }
      return _results;
    })();
    return out;
  };

  exports.colgrep = colgrep = function(_arg) {
    var buffer, cols, found, indices, k, line, lines, max_index, out, patterns, separator, v, _i, _len;
    patterns = _arg.patterns, buffer = _arg.buffer, separator = _arg.separator;
    lines = buffer.toString('utf8').split('\n');
    indices = (function() {
      var _results;
      _results = [];
      for (k in patterns) {
        v = patterns[k];
        _results.push(parseInt(k));
      }
      return _results;
    })();
    max_index = Math.max.apply(Math, indices);
    out = [];
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      if (!(((cols = line.split(separator)) != null) && (max_index < cols.length))) {
        continue;
      }
      found = true;
      for (k in patterns) {
        v = patterns[k];
        if (!cols[k].match(v)) {
          found = false;
          break;
        }
      }
      if (found) {
        out.push(cols);
      }
    }
    return out;
  };

}).call(this);
