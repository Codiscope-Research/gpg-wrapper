// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var E, GPG, Message, Packet, Parser, err, iced, msg, packet, parse, strip, util, __iced_deferrals, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  E = require('./err').E;

  GPG = require('./gpg').GPG;

  util = require('util');

  strip = function(x) {
    var m;
    if ((m = x.match(/^\s*(.*)$/))) {
      return m[1];
    } else {
      return x;
    }
  };

  Packet = (function() {
    function Packet(_arg) {
      this.type = _arg.type, this.options = _arg.options;
      this._subfields = [];
    }

    Packet.prototype.add_subfield = function(f) {
      return this._subfields.push(f);
    };

    return Packet;

  })();

  Message = (function() {
    function Message(packets) {
      this.packets = packets;
    }

    return Message;

  })();

  exports.Parser = Parser = (function() {
    function Parser(pgp_output) {
      this.pgp_output = pgp_output;
    }

    Parser.prototype.run = function() {
      this.preprocess();
      return new Message(this.parse_packets());
    };

    Parser.prototype.preprocess = function() {
      var line;
      return this._lines = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pgp_output.split("\n");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (line.match(/\S/)) {
            _results.push(line);
          }
        }
        return _results;
      }).call(this);
    };

    Parser.prototype.parse_packets = function() {
      var _results;
      _results = [];
      while (!this.eof()) {
        _results.push(this.parse_packet());
      }
      return _results;
    };

    Parser.prototype.peek = function() {
      return this._lines[0];
    };

    Parser.prototype.get = function() {
      return this._lines.shift();
    };

    Parser.prototype.eof = function() {
      return this._lines.length === 0;
    };

    Parser.prototype.parse_packet = function() {
      var first, m, packet, rxx;
      rxx = /^:([a-zA-Z0-9_ -]+) packet:( (.*))?$/;
      first = this.get();
      if (!(m = first.match(rxx))) {
        console.log(first);
        throw new E.ParseError("expected ':literal data packet:' style header");
      }
      packet = new Packet({
        type: m[1],
        options: m[3]
      });
      while (!(this.eof() || this.peek()[0] === ':')) {
        packet.add_subfield(strip(this.get()));
      }
      return packet;
    };

    return Parser;

  })();

  exports.parse = parse = function(_arg, cb) {
    var buf, e, err, gpg, message, packet, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    gpg = _arg.gpg, packet = _arg.packet;
    gpg || (gpg = new GPG);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/gpg-wrapper/src/parse.iced"
        });
        gpg.run({
          args: ["--list-packets"],
          stdin: packet
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return buf = arguments[1];
            };
          })(),
          lineno: 51
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        packets = null;
        if (typeof err === "undefined" || err === null) {
          try {
            message = (new Parser(buf.toString('utf8'))).run();
          } catch (_error) {
            e = _error;
            err = e;
          }
        }
        return cb(err, message);
      };
    })(this));
  };

  packet = "-----BEGIN PGP MESSAGE-----\nVersion: GnuPG/MacGPG2 v2.0.22 (Darwin)\nComment: GPGTools - https://gpgtools.org\n\nowEBPALD/ZANAwAKAS/gHEVDSNo5AcsMYgBSzEhJaGVsbG8KiQIcBAABCgAGBQJS\nzEhJAAoJEC/gHEVDSNo5d5gQAMHe2bPIFLL8wdu+KG9rkSqZ3iHloaHTkhN729T1\n+OefN1YeS7RpOHMcptNKtu36f9LFeDUCfgeevXcL3v3f5Crvl1TCmAft87HlsqZ0\n2L++qULRkauu2+HYHB0tr5RwaTYH8A3rYLD79Atrh0XStHcsh3C6ISmePEl+eStE\n3uhaEZ+r/PTKxN7/+qh8tGQuhRTI1fC/3rZmDqHQigTJm6pBvy/kDeATVdKevpbZ\nbrM+1jWITs+c2UkbZLmmIqHEe3JZrkvk6wP96HSTZkopMtyqMUnkdZLwe3MsYtPc\naiB3xGD5K5EZeVOkYAyfbpm0QhuPg9sNF16D+qhoie7vvVOeoKA5wpI8aQ6rnbCc\no/sUUlcMV1UaqeOqazXEEusAzw/Mh6mE7FIgW5f2DWzmu4BKcvbGJBbtxVAjVX6x\nomaUjqVVDLXahbZefwC5VuKYe5DySzWFGVCoJ1Jh+kNtvRXRBzsODA2tQcRVKRxH\npYfYhCSN95qFV+EfYuuvRLSsUSqn4jDE2QHzxl6zi0NWvvFWPLAmr8pitEm62E8g\nAUY4cbCb+KksTAin1xayDWYuTsmLaMSBkOdo7/HElf0y17a7+FbNy/lzlMylcs23\nOCRE6vCa7Pk9dsHC7OlRcG5rEGFnKuZfnZdftM7nUFNtbIozdvGeJzRn9a4roRw2\nfWti\n=QoKV\n-----END PGP MESSAGE-----";

  (function(_this) {
    return (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        filename: "/Users/max/src/gpg-wrapper/src/parse.iced"
      });
      parse({
        packet: packet
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return msg = arguments[1];
          };
        })(),
        lineno: 83
      }));
      __iced_deferrals._fulfill();
    });
  })(this)((function(_this) {
    return function() {
      console.log(err);
      return console.log(util.inspect(msg, {
        depth: null
      }));
    };
  })(this));

}).call(this);
